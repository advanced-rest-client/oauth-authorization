<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../cryptojs-lib/cryptojs-lib.html">
<link ref="import" href="../iron-meta/iron-meta.html">
<link ref="import" href="jsrsasign-import.html">
<!--
The `<outh2-authorization>` performs an OAuth2 requests to get a token for given settings.

There are 4 basic token requests flows:
- Authorization Code for apps running on a web server (`authorization_code` type)
- Implicit for browser-based or mobile apps (`implicit` type)
- Password for logging in with a username and password (`password` type)
- Client credentials for application access (`client_credentials` type)

This element uses them all.

Main function is the `authorize()` function that can be also used via event system.
This function accepts different set of parameters depending on request type. However it will
not perform a validation on the settings. It will try to perform the request for given set of
parameters. If it fails, than it fail on the server side.

### Example
```
<outh2-authorization></outh2-authorization>
```
```
var settings = {
  type: 'implicit',
  clientId: 'CLIENT ID',
  redirectUrl: 'https://example.com/auth-popup.html',
  authorizationUrl: 'https://auth.example.com/token'
  scopes: ['email']
};
var factory = document.querySelector('outh2-authorization');
factory.authorize(settings)

// or event based
var event = new CustomEvent('oauth2-token-requested', { 'detail': settings, bubbles: true });
document.dispatchEvent(event);
```

There is one difference for from using event based approach. When the token has been received
this will set `tokenValue` property on the target of the event.
The event will be canceled one it reach this element so other elements will not double the action.

An element or app that requesting the token should observe the `oauth2-token-response` and
`oauth2-error` events to get back the response.

## Popup in authorization flow
This element conatin a `oauth-popup.html` that can be used to exchange token / code data with
hosting page. Other page can be used as well. But in must `window.postMessage` back to the
`window.opener`. The structure of the message if the parsed query or has string to the map
of parameters. Furthermore it must camel case the parameters. Example script is source code
of the `oauth-popup.html` page.
Popup should be served over the SSL.

## The state parameter and security
This element is intened to be used in debug applications where confidentialy is already
compromised because users may be asked to provide client secret parameter (depending on the flow).
**It should not be used in client applications** that don't serve debugging purposes.
Client secret should never be used on the client side.

To have at least minimum of protection (in already compromised environment) this library generates
a `state` parameter as a series of alphanumeric characters and append them to the request.
It is expected to return the same string in the response (as defined in rfc6749). Though this
parameter is optional, it will reject the response if the `state` parameter is not the same as the
one generated before the request.

## Demo
See `auth-methods` > `auth-method-oauth2` element for the demo.

## Acknowledgements

- This element uses [jsrsasign](https://github.com/kjur/jsrsasign) library distributed
under MIT licence.
- This element uses [crypto-js](https://code.google.com/archive/p/crypto-js/) libraty
distributed under BSD license.

@group Logic Elements
@element oauth-authorization
-->
<script>
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
// jscs:disable requireDotNotation
(function() {
  'use strict';

  Polymer({
    is: 'oauth1-authorization',

    properties: {
      // A full data returned by the authorization endpoint.
      tokenInfo: {
        type: Object,
        readOnly: true
      },
      proxy: String,
      _caseMap: {
        type: Object,
        value: {}
      },
      _camelRegex: {
        type: Object,
        value: function() {
          return /([A-Z])/g;
        }
      }
    },

    attached: function() {
      this.listen(window, 'oauth1-token-requested', '_tokenRequestedHandler');
      this.listen(window, 'message', '_listenPopup');
    },

    detached: function() {
      this.unlisten(window, 'oauth1-token-requested', '_tokenRequestedHandler');
      this.unlisten(window, 'message', '_listenPopup');
    },

    _tokenRequestedHandler: function(e, detail) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      this.authorize(detail);
    },

    authorize: function(settings) {
      console.log(settings);
      // settings = this.prepareParameters(settings);
      this._prepareOauth(settings);
      this.getOAuthRequestToken();
      // .then(function(token) {
      //   debugger;
      //   token.sign(request);
      // });
    },

    _prepareOauth: function(params) {
      this._requestUrl = params.requestTokenUrl;
      this._accessUrl = params.accessTokenUrl;
      this._consumerKey = params.consumerKey;
      this._consumerSecret = params.consumerSecret;
      var signMethod = params.signatureMethod;
      if (signMethod === 'RSA-SHA1') {
        this._privateKey = params.consumerSecret;
      }
      this._version = params.version || '1.0';
      if (!params.redirectUrl) {
        this._authorizeCallback = 'oob';
      } else {
        this._authorizeCallback = params.redirectUrl;
      }
      //&& signMethod !== 'RSA-SHA1'
      if (signMethod !== 'PLAINTEXT' && signMethod !== 'HMAC-SHA1') {
        throw new Error('Un-supported signature method: ' + signMethod);
      }
      this._signatureMethod = signMethod;
      this._nonceSize = params.nonceSize || 32;
      this._nonce = params.nonce;
      this._timestamp = params.timestamp;
      this._headers = params.customHeaders || this._defaultHeaders();
      this._oauthParameterSeperator = ',';
      this._authParamsLocation = params.authParamsLocation || 'authorization';
      this._authTokenMethod = params.authTokenMethod || 'POST';
    },

    _defaultHeaders: function() {
      return {
        'Accept': '*/*',
        'Connection': 'close',
        'User-Agent': 'Advanced REST Client authorization'
      };
    },
    /**
     * Returns current timestamp.
     *
     * @return {Number} Current timestamp
     */
    getTimestamp: function() {
      return Math.floor((new Date()).getTime() / 1000);
    },
    /**
     * URL encodes the string.
     *
     * @param {String} toEncode A string to encode.
     * @return {String} Encoded string
     */
    encodeData: function(toEncode) {
      if (!toEncode) {
        return '';
      }
      var result = encodeURIComponent(toEncode);
      return result.replace(/\!/g, '%21')
        .replace(/\'/g, '%27')
        .replace(/\(/g, '%28')
        .replace(/\)/g, '%29')
        .replace(/\*/g, '%2A');
    },
    /**
     * URL decodes data.
     * Also replaces `+` with ` ` (space).
     *
     * @param {String} toDecode String to decode.
     * @return {String} Decoded string
     */
    decodeData: function(toDecode) {
      if (!toDecode) {
        return '';
      }
      toDecode = toDecode.replace(/\+/g, ' ');
      return decodeURIComponent(toDecode);
    },
    /**
     * Computes signature for the request.
     *
     * @param {String} signatureMethod Method to use to generate the signature.
     * Supported are: `PLAINTEXT`, `HMAC-SHA1`, `RSA-SHA1`. It throws an error if
     * value of this property is other than listed here.
     * @param {String} requestMethod Request HTTP method.
     * @param {String} url Request full URL.
     * @param {Object} oauthParameters Map of oauth parameters.
     * @param {?String} tokenSecret Optional, token secret.
     * @return {String} Generated OAuth1 signature for given `signatureMethod`
     * @param {?String} body Body used with the request. Note: this parameter
     * can only be set if the request's content-type header equals
     * `application/x-www-form-urlencoded`.
     * @throws Error when `signatureMethod` is not one of listed here.
     */
    getSignature: function(signatureMethod, requestMethod, url, oauthParameters, tokenSecret, body) {
      var signatureBase;
      var key;
      if (signatureMethod !== 'PLAINTEXT') {
        signatureBase = this.createSignatureBase(requestMethod, url, oauthParameters, body);
        console.log('BASE', signatureBase);
      }
      if (signatureMethod !== 'RSA-SHA1') {
        key = this.createSignatureKey(this._consumerSecret, tokenSecret);
        console.log('KEY', key);
      }

      switch (signatureMethod) {
        case 'PLAINTEXT':
          return this._createSignaturePlainText(key);
        case 'RSA-SHA1':
          return this._createSignatureRsaSha1(signatureBase, this._privateKey);
        case 'HMAC-SHA1':
          return this._createSignatureHamacSha1(signatureBase, key);
        default:
          throw new Error('Unknown signature method');
      }
    },
    /**
     * Normalizes URL to base string URI as described in
     * https://tools.ietf.org/html/rfc5849#section-3.4.1.2
     *
     * @param {String} url Request full URL.
     * @return {String} Base String URI
     */
    _normalizeUrl: function(url) {
      var parsedUrl = new URL(url);
      var port = '';
      if (parsedUrl.port) {
        if ((parsedUrl.protocol === 'http:' && parsedUrl.port !== '80') ||
          (parsedUrl.protocol === 'https:' && parsedUrl.port !== '443')) {
          port = ':' + parsedUrl.port;
        }
      }
      if (!parsedUrl.pathname || parsedUrl.pathname === '') {
        parsedUrl.pathname = '/';
      }
      return parsedUrl.protocol + '//' + parsedUrl.hostname + port + parsedUrl.pathname;
    },

    /**
     * @param {String} parameter Parameter name (key).
     * @return {Boolean} True if the `parameter` is an OAuth 1 parameter.
     */
    _isParameterNameAnOAuthParameter: function(parameter) {
      return parameter.indexOf('oauth_') === 0;
    },
    /**
     * Creates an Authorization header value to trasmit OAuth params in headers
     * as described in https://tools.ietf.org/html/rfc5849#section-3.5.1
     *
     * @param {Array} orderedParameters Oauth parameters that are already
     * ordered.
     * @return {String} The Authorization header value
     */
    _buildAuthorizationHeaders: function(orderedParameters) {
      var authHeader = 'OAuth ';
      // if (this._isEcho) {
      //   authHeader += 'realm="' + this._realm + '",';
      // }
      var params = orderedParameters.map(function(item) {
          if (!this._isParameterNameAnOAuthParameter(item[0])) {
            return;
          }
          return this.encodeData(item[0]) + '="' + this.encodeData(item[1]) + '"';
        }, this)
        .filter(function(item) {
          return !!item;
        });
      authHeader += params.join(this._oauthParameterSeperator + ' ');
      return authHeader;
    },
    /**
     * Creates a body for www-urlencoded content type to transmit OAuth params
     * in request body as described in
     * https://tools.ietf.org/html/rfc5849#section-3.5.2
     *
     * @param {Array} orderedParameters Oauth parameters that are already
     * ordered.
     * @return {String} The body to send
     */
    _buildFormDataParameters: function(orderedParameters) {
      return orderedParameters.map(function(item) {
        if (!this._isParameterNameAnOAuthParameter(item[0])) {
          return;
        }
        return this.encodeData(item[0]) + '=' + this.encodeData(item[1]);
      }, this)
      .filter(function(item) {
        return !!item;
      })
      .join('&');
    },
    /**
     * Adds query paramteres with OAuth 1 parameters to the URL
     * as described in https://tools.ietf.org/html/rfc5849#section-3.5.3
     *
     * @param {Array} orderedParameters Oauth parameters that are already
     * ordered.
     * @return {String} URL to use with the request
     */
    _buildAuthorizationQueryStirng: function(url, orderedParameters) {
      var urlParser = new URL(url);
      var sParams = urlParser.searchParams;
      orderedParameters.forEach(function(param) {
        sParams.append(param[0], param[1]);
      });
      url = urlParser.toString();
      return url;
    },
    // Takes an object literal that represents the arguments, and returns an array
    // of argument/value pairs.
    _makeArrayOfArgumentsHash: function(argumentsHash) {
      var argumentPairs = [];
      Object.keys(argumentsHash).forEach(function(key) {
        var value = argumentsHash[key];
        if (Array.isArray(value)) {
          for (var i = 0; i < value.length; i++) {
            argumentPairs[argumentPairs.length] = [key, value[i]];
          }
        } else {
          argumentPairs[argumentPairs.length] = [key, value];
        }
      });
      return argumentPairs;
    },

    // Sorts the encoded key value pairs by encoded name, then encoded value
    _sortRequestParams: function(argumentPairs) {
      // Sort by name, then value.
      argumentPairs.sort(function(a, b) {
        if (a[0] === b[0]) {
          return a[1] < b[1] ? -1 : 1;
        } else {
          return a[0] < b[0] ? -1 : 1;
        }
      });
      return argumentPairs;
    },
    /**
     * Sort function to sort parameters as described in
     * https://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
     */
    _sortParamsFunction: function(a, b) {
      if (a[0] === b[0]) {
        return String(a[1]).localeCompare(String(b[1]));
      }
      return String(a[0]).localeCompare(String(b[0]));
    },
    /**
     * Normalizes request parameters as described in
     * https://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
     *
     * @param {Array} args List of parameters to normalize. It must contain
     * a list of array items where first element of the array is parameter name
     * and second is parameter value.
     * @return {String} Normalized parameters to string.
     */
    _normaliseRequestParams: function(args) {
      var len = args.length;
      var i = 0;
      // First encode them #3.4.1.3.2 .1
      for (; i < len; i++) {
        args[i][0] = this.encodeData(args[i][0]);
        args[i][1] = this.encodeData(args[i][1]);
      }

      // Then sort them #3.4.1.3.2 .2
      args.sort(this._sortParamsFunction);

      // Then concatenate together #3.4.1.3.2 .3 & .4
      var result = args.map(function(pair) {
        if (pair[0] === 'oauth_signature') {
          return;
        }
        return pair[0] + '=' + String(pair[1]);
      })
      .filter(function(item) {
        return !!item;
      })
      .join('&');
      return result;
    },
    /**
     * Computes array of parameters from the request URL.
     *
     * @param {String} url Full request URL
     * @return {Array} Array of parameters where each item is an array with
     * first element as a name of the parameter and second element as a value.
     */
    _listQueryParameters: function(url) {
      var result = [];
      var parsedUrl = new URL(url);
      var iterator = parsedUrl.searchParams.entries();
      while (true) {
        var item = iterator.next();
        if (item.done) {
          break;
        }
        var _param = item.value;
        result.push([_param[0], _param[1]]);
      }
      return result;
    },
    /**
     * Computes array of parameters from the entity body.
     * The body must be `application/x-www-form-urlencoded`.
     *
     * @param {String} body Entity body of `application/x-www-form-urlencoded`
     * request
     * @return {Array} Array of parameters where each item is an array with
     * first element as a name of the parameter and second element as a value.
     * Keys and values are percent decoded. Additionally each `+` is replaced
     * with space character.
     */
    _formUrlEncodedToParams: function(body) {
      if (!body) {
        return [];
      }
      var parts = body.split('&').map(function(part) {
        var pair = part.split('=');
        var key = this.decodeData(pair[0]);
        var value = '';
        if (pair[1]) {
          value = this.decodeData(pair[1]);
        }
        return [key, value];
      }, this);
      return parts;
    },
    /**
     * Creates a signature base as defined in
     * https://tools.ietf.org/html/rfc5849#section-3.4.1
     *
     * @param {String} method HTTP method used with the request
     * @param {String} url Full URL of the request
     * @param {Object} oauthParams Key - value pairs of OAuth parameters
     * @param {?String} body Body used with the request. Note: this parameter
     * can only be set if the request's content-type header equals
     * `application/x-www-form-urlencoded`.
     * @return {String} A base string to be used to generate signature.
     */
    createSignatureBase: function(method, url, oauthParams, body) {
      var allParameter = [];
      var uriParameters = this._listQueryParameters(url);
      oauthParams = this._makeArrayOfArgumentsHash(oauthParams);
      allParameter = uriParameters.concat(oauthParams);
      if (body) {
        body = this._formUrlEncodedToParams(body);
        allParameter = allParameter.concat(body);
      }
      allParameter = this._normaliseRequestParams(allParameter);
      allParameter = this.encodeData(allParameter);
      url = this.encodeData(this._normalizeUrl(url));
      return [method.toUpperCase(), url, allParameter].join('&');
    },
    /**
     * Creates a signature key to compute the signature as described in
     * https://tools.ietf.org/html/rfc5849#section-3.4.2
     *
     * @param {String} clientSecret Client secret (consumer secret).
     * @param {?String} tokenSecret Optional, token secret
     * @return {String} A key to be used to generate the signature.
     */
    createSignatureKey: function(clientSecret, tokenSecret) {
      if (!tokenSecret) {
        tokenSecret = '';
      } else {
        tokenSecret = this.encodeData(tokenSecret);
      }
      clientSecret = this.encodeData(clientSecret);
      return clientSecret + '&' + tokenSecret;
    },
    /**
     * Found at http://jsfiddle.net/ARTsinn/6XaUL/
     *
     * @param {String} h Hexadecimal input
     * @return {String} Result of transforming value to string.
     */
    hex2b64: function(h) {
      var b64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      var b64pad = '=';
      var i;
      var c;
      var ret = '';
      for (i = 0; i + 3 <= h.length; i += 3) {
        c = parseInt(h.substring(i, i + 3), 16);
        ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
      }
      if (i + 1 === h.length) {
        c = parseInt(h.substring(i, i + 1), 16);
        ret += b64map.charAt(c << 2);
      } else if (i + 2 === h.length) {
        c = parseInt(h.substring(i, i + 2), 16);
        ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
      }
      while ((ret.length & 3) > 0) {
        ret += b64pad;
      }
      return ret;
    },
    /**
     * Creates a signature for the PLAINTEXT method.
     *
     * In this case the signature is the key.
     *
     * @param {String} baseText Computed signature base text.
     * @param {String} key Computed signature key.
     * @return {String} Computed OAuth1 signature.
     */
    _createSignaturePlainText: function(key) {
      return key;
    },
    /**
     * Creates a signature for the RSA-SHA1 method.
     *
     * @param {String} baseText Computed signature base text.
     * @param {String} privateKey Client private key.
     * @return {String} Computed OAuth1 signature.
     */
    _createSignatureRsaSha1: function(baseText, privateKey) {
      var rsa = new RSAKey();
      rsa.readPrivateKeyFromPEMString(privateKey);
      var hSig = rsa.sign(baseText, 'sha1');
      return this.hex2b64(hSig);
    },
    /**
     * Creates a signature for the HMAC-SHA1 method.
     *
     * @param {String} signatureBase Computed signature base text.
     * @param {String} key Computed signature key.
     * @return {String} Computed OAuth1 signature.
     */
    _createSignatureHamacSha1: function(baseText, key) {
      var hash = CryptoJS.HmacSHA1(baseText, key);
      return hash.toString(CryptoJS.enc.Base64);
    },

    get nonceChars() {
      return [
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B',
        'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3',
        '4', '5', '6', '7', '8', '9'
      ];
    },

    _getNonce: function(nonceSize) {
      var result = [];
      var chars = this.nonceChars;
      var charPos;
      var nonceCharsLength = chars.length;

      for (var i = 0; i < nonceSize; i++) {
        charPos = Math.floor(Math.random() * nonceCharsLength);
        result[i] = chars[charPos];
      }
      return result.join('');
    },

    _prepareParameters: function(token, tokenSecret, method, url, extraParams) {
      var oauthParameters = {
        'oauth_timestamp': this._timestamp || this._getTimestamp(),
        'oauth_nonce': this._nonce || this._getNonce(this._nonceSize),
        'oauth_version': this._version,
        'oauth_signature_method': this._signatureMethod,
        'oauth_consumer_key': this._consumerKey
      };

      if (token) {
        oauthParameters.oauth_token = token;
      }

      var sig;
      if (this._isEcho) {
        sig = this.getSignature(this._signatureMethod, 'GET',
          this._verifyCredentials, oauthParameters, tokenSecret);
      } else {
        if (extraParams) {
          Object.keys(extraParams).forEach(function(key) {
            oauthParameters[key] = extraParams[key];
          });
        }
        sig = this.getSignature(this._signatureMethod, method, url, oauthParameters, tokenSecret);
      }

      var orderedParameters = this._sortRequestParams(
        this._makeArrayOfArgumentsHash(oauthParameters));
      orderedParameters[orderedParameters.length] = ['oauth_signature', sig];
      return orderedParameters;
    },
    //
    encodeUriParams: function(params) {
      var result = Object.keys(params).map(function(key) {
        return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
      });
      return result.join('&');
    },

    _performRequest: function(token, tokenSecret, method, url, extraParams, body, contentType) {
      var withPayload = ['POST', 'PUT'].indexOf(method) !== -1;

      var orderedParameters = this._prepareParameters(token, tokenSecret, method, url, extraParams);
      if (withPayload && !contentType) {
        contentType = 'application/x-www-form-urlencoded';
      }
      var headers = {};
      if (this._authParamsLocation === 'authorization') {
        var authorization = this._buildAuthorizationHeaders(orderedParameters);
        if (this._isEcho) {
          headers['X-Verify-Credentials-Authorization'] = authorization;
        } else {
          headers.authorization = authorization;
        }
      } else {
        url = this._buildAuthorizationQueryStirng(url, orderedParameters);
      }
      if (this._headers) {
        Object.keys(this._headers).forEach(function(key) {
          headers[key] = this._headers[key];
        }, this);
      }
      if (extraParams) {
        Object.keys(extraParams).forEach(function(key) {
          if (this._isParameterNameAnOAuthParameter(key)) {
            delete extraParams[key];
          }
        }, this);
      }

      if (withPayload && (extraParams && !body) && ['POST', 'PUT'].indexOf(method) !== -1) {
        body = this.encodeUriParams(extraParams)
        .replace(/\!/g, '%21')
        .replace(/\'/g, '%27')
        .replace(/\(/g, '%28')
        .replace(/\)/g, '%29')
        .replace(/\*/g, '%2A');
      }

      if (withPayload && !body) {
        headers['Content-length'] = '0';
      }

      var init = {
        method: method,
        headers: headers
      };
      if (withPayload && body) {
        init.body = body;
      }
      debugger;
      var responseHeaders;
      return this.request(url, init).then(function(response) {
        if (!response.ok) {
          throw new Error('Token request error ended with status ' + response.status);
        }
        responseHeaders = response.headers;
        return response.text();
      })
      .then(function(text) {
        return {
          response: text,
          headers: responseHeaders
        };
      });
    },

    getOAuthAccessToken: function(token, secret, verifier) {
      var extraParams = {};
      if (typeof verifier !== 'function') {
        extraParams.oauth_verifier = verifier;
      }
      var method = this._authTokenMethod;
      return this._performRequest(token, secret, method, this._accessUrl, extraParams)
      .then(function(response) {
        console.log(response);
      });
    },

    getOAuthRequestToken: function(extraParams) {
      extraParams = extraParams || {};
      if (this._authorizeCallback) {
        extraParams.oauth_callback = this._authorizeCallback;
      }
      var method = this._authTokenMethod;
      return this._performRequest(null, null, method, this._requestUrl, extraParams)
      .then(function(response) {
        console.log(response);
      });
    },

    request: function(url, init) {
      var event = this.fire('auth-request-proxy', {
        url: init,
        init: init
      }, {
        cancelable: true,
        composed: true
      });
      var p;
      if (event.defaultPrevented) {
        p = event.detail.result;
      } else {
        p = this._fetch(url, init);
      }
      return p;
    },

    _fetch: function(url, init) {
      var proxy;
      if (this.proxy) {
        proxy = this.proxy;
      } else {
        proxy = document.createElement('iron-meta').byKey('auth-proxy');
      }
      if (proxy) {
        url = proxy + url;
      }
      init.mode = 'cors';
      return fetch(url, init);
    }

    // prepareParameters: function(settings) {
    //   ['consumerKey', 'consumerSecret', 'signatureMethod', 'timestamp',
    //     'nonce', 'token', 'tokenSecret', 'realm'
    //   ]
    //   .forEach(function(key) {
    //     settings = this._parseParameter(key, settings);
    //   }, this);
    //   return settings;
    // },
    //
    // _parseParameter: function(param, settings) {
    //   if (!(param in settings)) {
    //     return settings;
    //   }
    //   var value = settings[param];
    //   var oauthParam;
    //   if (this._caseMap[param]) {
    //     oauthParam = this._caseMap[param];
    //   } else {
    //     oauthParam = this._getCaseParam(param);
    //   }
    //   settings[oauthParam] = value;
    //   return settings;
    // },
    //
    // _getCaseParam: function(param) {
    //   return 'oauth_' + param.replace(this._camelRegex, '_$1').toLowerCase();
    // }
  });
})();
</script>
